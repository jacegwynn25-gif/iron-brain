# SFR "All Red/Excessive" Bug - Root Cause Analysis

## Issue Summary
Every single exercise in the SFR Insights table shows "excessive" (red) rating, which is impossible. This indicates a fundamental flaw in how fatigue is being assigned to exercises for SFR calculation.

## Root Cause: Temporal Attribution Error

### The Bug (sfr.ts lines 208-210)

```typescript
const relevantFatigue = fatigueScores
  .filter(fs => fs.contributingSets.some(s => s.exerciseId === exerciseId))
  .reduce((max, fs) => Math.max(max, fs.fatigueLevel), 0);
```

### Why This Is Wrong

The code calculates fatigue for ALL muscle groups using ALL completed sets from the entire workout, then tries to attribute that cumulative fatigue back to individual exercises. This creates a **temporal attribution error**.

#### Example Scenario:

**Workout Order:**
1. Bench Press (3 sets @ RPE 8) - First exercise, no prior fatigue
2. Overhead Press (3 sets @ RPE 9) - Creates shoulder fatigue
3. Tricep Extensions (3 sets @ RPE 8) - Creates tricep fatigue

**What Should Happen:**
- Bench Press SFR: High (no fatigue accumulated yet, fresh muscles)
- Overhead Press SFR: Moderate (some shoulder fatigue from bench)
- Tricep Extensions SFR: Lower (accumulated fatigue from bench + OHP)

**What Actually Happens:**

1. `calculateMuscleFatigue` is called with ALL sets after workout completion
2. It calculates:
   - Chest fatigue: 15 (from bench overshoots)
   - Shoulder fatigue: 45 (from bench + OHP overshoots)
   - Tricep fatigue: 60 (from bench + OHP + extensions overshoots)

3. When calculating Bench Press SFR:
   - Filters to muscle groups where Bench contributed: [chest, shoulders, triceps]
   - Takes MAX: `Math.max(15, 45, 60) = 60`
   - **Bench Press inherits fatigue from exercises that happened AFTER it!**

4. Result:
   - Bench effective volume: 4860
   - Bench assigned fatigue: 60 (wrong - should be ~0-5)
   - Bench SFR: 4860 / 60 = 81 → **"POOR/EXCESSIVE"** (should be "EXCELLENT")

## The Fundamental Conceptual Error

**SFR Concept:** Stimulus-to-Fatigue Ratio should measure how much productive stimulus an exercise generated relative to how much fatigue it cost.

**Current Implementation:** Measures stimulus generated by an exercise relative to how much TOTAL ACCUMULATED fatigue exists in all muscle groups it touches by the end of the workout.

This is like measuring the "cost-effectiveness" of your first grocery item based on the total cost of all groceries you bought that day.

## Why Everything Shows "Excessive"

1. **Compound movements hit multiple muscle groups** (bench: chest/shoulders/triceps)
2. **Those muscle groups accumulate fatigue throughout the workout**
3. **Each exercise inherits the MAX fatigue across all its muscle groups**
4. **By the end of a workout, muscle group fatigue is high (20-60+)**
5. **High fatigue ÷ by effective volume = low SFR = "excessive"**

### Mathematical Proof

Typical values:
- Effective volume per exercise: 2000-5000
- Muscle group fatigue by workout end: 30-60
- SFR: 2000-5000 / 30-60 = 33-166
- Thresholds: <50 = excessive, 50-100 = poor, 100-150 = moderate
- **Result: Almost everything falls in poor/excessive range**

## Additional Issues Identified

### Issue #2: Fatigue Only Counts Overshoots

From `fatigueModel.ts` line 249-252:
```typescript
const rpeOvershoot = set.actualRPE - set.prescribedRPE;

// Only count overshoots (negative = undershoot, ignore)
if (rpeOvershoot <= 0) continue;
```

**Problem:** If a user executes sets perfectly (actualRPE = prescribedRPE), fatigue = 0.

**Why This Is Wrong for SFR:**
- SFR is measuring training efficiency
- A set at RPE 8 (perfect execution) still creates fatigue!
- Only counting OVERSHOOT means perfect execution = 0 fatigue = infinite SFR
- This conflates "RPE calibration accuracy" with "actual fatigue cost"

**Example:**
- Perfect execution: 3 sets @ RPE 8 (actual = prescribed)
- Overshoot = 0, so fatigue contribution = 0
- But RPE 8 sets still create real physiological fatigue!

### Issue #3: Wrong Conceptual Model

The fatigue model was designed for **auto-regulation** (detecting when to reduce weight during a workout), NOT for **post-workout efficiency analysis**.

**Auto-regulation needs:** Detect when fatigue is higher than expected (overshoots)
**SFR needs:** Measure total fatigue cost regardless of accuracy

## The Correct Approach

### Option 1: Per-Exercise Fatigue Calculation (RECOMMENDED)

Instead of calculating fatigue for all muscle groups post-workout, calculate it PER EXERCISE using only sets BEFORE that exercise:

```typescript
export function calculateWorkoutSFR(
  sets: SetLog[],
  fatigueScores: FatigueScore[] // UNUSED - calculate per exercise instead
): WorkoutSFRSummary {
  // Group sets by exercise
  const setsByExercise = new Map<string, SetLog[]>();
  sets.forEach(set => {
    if (!setsByExercise.has(set.exerciseId)) {
      setsByExercise.set(set.exerciseId, []);
    }
    setsByExercise.get(set.exerciseId)!.push(set);
  });

  const exerciseAnalyses: SFRAnalysis[] = [];
  const completedExercises: string[] = [];

  // Sort exercises by when they occurred (use set timestamps or order)
  const exerciseOrder = Array.from(setsByExercise.entries())
    .sort((a, b) => {
      const aFirstSet = a[1][0];
      const bFirstSet = b[1][0];
      // Assuming sets have timestamps or we can use setIndex
      return (aFirstSet.timestamp || 0) - (bFirstSet.timestamp || 0);
    });

  // Process exercises in chronological order
  for (const [exerciseId, exerciseSets] of exerciseOrder) {
    // Calculate fatigue from ONLY sets that came before this exercise
    const priorSets = sets.filter(s => {
      // Only include completed sets from exercises that came before this one
      return s.completed && completedExercises.includes(s.exerciseId);
    });

    // Get muscle groups for this exercise
    const exercise = defaultExercises.find(ex => ex.id === exerciseId);
    const targetMuscles = exercise?.muscleGroups.map(mg => mg.toLowerCase()) || [];

    // Calculate fatigue in those muscles from prior work
    const priorFatigue = calculateMuscleFatigue(priorSets, targetMuscles);

    // Use weighted average instead of max (primary muscles weighted higher)
    const relevantFatigue = calculateWeightedFatigue(priorFatigue, exercise);

    const analysis = calculateExerciseSFR(
      exerciseSets,
      relevantFatigue,
      exercise?.name || exerciseId
    );

    exerciseAnalyses.push(analysis);
    completedExercises.push(exerciseId);
  }

  // ... rest of function
}
```

### Option 2: Exercise-Specific Fatigue Cost Model

Calculate fatigue based on the exercise's OWN sets, not accumulated fatigue:

```typescript
function calculateExerciseFatigueCost(sets: SetLog[]): number {
  let totalCost = 0;

  for (const set of sets) {
    if (!set.completed) continue;

    const rpe = set.actualRPE || set.prescribedRPE || 7;
    const reps = set.actualReps || 0;
    const weight = set.actualWeight || 0;

    // Fatigue cost based on intensity and volume
    // Higher RPE = exponentially more fatigue
    const intensityFactor = Math.pow(rpe / 10, 2); // RPE 10 = 1.0, RPE 5 = 0.25
    const volumeFactor = reps * (weight / 100); // Normalize by weight

    // Modifiers
    const failureMult = set.reachedFailure ? 1.3 : 1.0;
    const formMult = set.formBreakdown ? 1.5 : 1.0;

    totalCost += intensityFactor * volumeFactor * failureMult * formMult;
  }

  return totalCost;
}
```

### Option 3: Separate Overshoot-Based and Volume-Based Fatigue

Keep overshoot-based fatigue for auto-regulation, create volume-based fatigue for SFR:

```typescript
interface FatigueMetrics {
  overshootFatigue: number;  // For auto-regulation (current model)
  volumeFatigue: number;     // For SFR (new model)
}
```

## Recommended Fix Priority

1. **HIGH PRIORITY:** Fix temporal attribution bug
   - Calculate fatigue per exercise using only prior sets
   - Or use exercise-specific fatigue cost model

2. **MEDIUM PRIORITY:** Separate fatigue models
   - Keep overshoot-based for auto-regulation
   - Add volume-based for SFR

3. **LOW PRIORITY:** Adjust thresholds
   - Current thresholds (>200 = excellent) may need recalibration
   - Depends on which fix is implemented

## Testing Strategy

Create test cases with known-good scenarios:

```javascript
// Test 1: First exercise with perfect execution
const freshExercise = {
  sets: [
    { weight: 225, reps: 8, actualRPE: 8, prescribedRPE: 8 }
  ],
  priorFatigue: 0
};
// Expected SFR: >200 (excellent)

// Test 2: Late workout exercise with high fatigue
const fatigued Exercise = {
  sets: [
    { weight: 135, reps: 10, actualRPE: 8, prescribedRPE: 8 }
  ],
  priorFatigue: 45
};
// Expected SFR: 50-100 (poor/moderate) - makes sense!

// Test 3: Junk volume (too much, too late)
const junkVolume = {
  sets: [
    { weight: 95, reps: 15, actualRPE: 7, prescribedRPE: 7 }
  ],
  priorFatigue: 60
};
// Expected SFR: <50 (excessive) - correct!
```

## Database Implications

The bug affects historical data in:
- `sfr_analyses` table - all SFR values are incorrectly low
- `exercise_efficiency_leaderboard` view - averages are wrong
- `workout_sfr_summaries` - overall metrics are wrong

**Options:**
1. Recalculate all historical SFR data after fix
2. Clear historical data and start fresh
3. Add a migration script to reprocess

## Summary

**The Core Issue:** Using post-workout cumulative fatigue to evaluate per-exercise efficiency creates a temporal causality violation. Early exercises inherit fatigue from later exercises, making everything appear inefficient.

**The Fix:** Calculate fatigue contextually (only from prior work) or use exercise-specific cost models.

**Expected Outcome:** SFR distribution should show:
- Early exercises: Mostly excellent/good
- Mid-workout: Good/moderate
- Late workout: Moderate/poor (appropriate!)
- Only truly junky volume: Excessive
