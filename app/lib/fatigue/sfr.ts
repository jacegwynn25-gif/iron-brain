/**
 * Stimulus-to-Fatigue Ratio (SFR) Analysis
 *
 * Research basis:
 * - Israetel et al. (2017): Volume landmarks (MEV, MAV, MRV)
 * - Schoenfeld (2010): Mechanisms of hypertrophy - effective reps concept
 * - Baz-Valle et al. (2021): Proximity to failure and hypertrophy
 *
 * Concept:
 * SFR = Effective Volume / Fatigue Cost
 *
 * High SFR (>200) = Productive training (good stimulus, manageable fatigue)
 * Low SFR (<50) = Junk volume (high fatigue cost, low benefit)
 */

import { logger } from '../logger';
import { SetLog } from '../types';
import { supabase } from '../supabase/client';
import { defaultExercises } from '../programs';
import { convertWeight } from '../units';

// ============================================================
// INTERFACES
// ============================================================

interface SFRAnalysis {
  exerciseId: string;
  exerciseName: string;
  totalSets: number;
  effectiveVolume: number;       // Volume-weighted by proximity to failure
  totalFatigue: number;           // Cumulative fatigue score
  sfr: number;                    // Stimulus-to-Fatigue Ratio
  interpretation: 'excellent' | 'good' | 'moderate' | 'poor' | 'excessive';
  recommendation: string;

  // Breakdown for insights
  avgRPE: number;
  totalVolumeLoad: number;        // Raw volume (sets × reps × weight)
  fatiguePerSet: number;
}

interface WorkoutSFRSummary {
  workoutSessionId: string;
  exerciseAnalyses: SFRAnalysis[];
  overallSFR: number;
  overallInterpretation: 'excellent' | 'good' | 'moderate' | 'poor' | 'excessive';
  insights: string[];
}

// ============================================================
// EFFECTIVE VOLUME CALCULATION
// ============================================================

/**
 * Calculate effective volume based on proximity to failure
 *
 * Research: Baz-Valle et al. (2021) - Sets closer to failure drive more growth
 *
 * Weighting:
 * - RPE 9-10 (0-1 RIR): 1.0x multiplier - maximum stimulus
 * - RPE 8 (2 RIR): 0.9x - very effective
 * - RPE 7 (3 RIR): 0.7x - moderately effective
 * - RPE 6 (4 RIR): 0.5x - minimally effective
 * - RPE <6: 0.2x - very low effectiveness (warm-up territory)
 */
function calculateEffectiveVolume(set: SetLog): number {
  const weight = set.actualWeight ?? 0;
  const weightLbs = weight > 0 ? convertWeight(weight, set.weightUnit ?? 'lbs', 'lbs') : 0;
  const volumeLoad = weightLbs * (set.actualReps || 0);
  const rpe = set.actualRPE || set.prescribedRPE || 7;

  let effectivenessMultiplier: number;

  if (rpe >= 9) {
    effectivenessMultiplier = 1.0; // Maximum stimulus
  } else if (rpe >= 8) {
    effectivenessMultiplier = 0.9; // Very effective
  } else if (rpe >= 7) {
    effectivenessMultiplier = 0.7; // Moderately effective
  } else if (rpe >= 6) {
    effectivenessMultiplier = 0.5; // Minimally effective
  } else {
    effectivenessMultiplier = 0.2; // Warm-up sets
  }

  return volumeLoad * effectivenessMultiplier;
}

// ============================================================
// SFR CALCULATION
// ============================================================

/**
 * Calculate SFR for a single exercise
 *
 * @param exerciseSets - All sets for this exercise in the workout
 * @param fatigueScore - Fatigue score generated by this exercise
 * @param exerciseName - Name for display purposes
 */
function calculateExerciseSFR(
  exerciseSets: SetLog[],
  fatigueScore: number,
  exerciseName: string
): SFRAnalysis {
  if (exerciseSets.length === 0) {
    return {
      exerciseId: '',
      exerciseName: '',
      totalSets: 0,
      effectiveVolume: 0,
      totalFatigue: 0,
      sfr: 0,
      interpretation: 'poor',
      recommendation: 'No sets logged',
      avgRPE: 0,
      totalVolumeLoad: 0,
      fatiguePerSet: 0,
    };
  }

  const exerciseId = exerciseSets[0].exerciseId;

  // Calculate total effective volume
  const effectiveVolume = exerciseSets.reduce(
    (sum, set) => sum + calculateEffectiveVolume(set),
    0
  );

  // Calculate raw volume load
  const totalVolumeLoad = exerciseSets.reduce((sum, set) => {
    const weight = set.actualWeight ?? 0;
    const reps = set.actualReps || 0;
    if (!weight || !reps) return sum;
    const weightLbs = convertWeight(weight, set.weightUnit ?? 'lbs', 'lbs');
    return sum + (weightLbs * reps);
  }, 0);

  // Calculate average RPE
  const rpeValues = exerciseSets.map(s => s.actualRPE || s.prescribedRPE || 7);
  const avgRPE = rpeValues.reduce((a, b) => a + b, 0) / rpeValues.length;

  // Prevent division by zero
  const effectiveFatigue = Math.max(fatigueScore, 1);

  // Calculate SFR
  const sfr = effectiveVolume / effectiveFatigue;

  // Fatigue per set
  const fatiguePerSet = fatigueScore / exerciseSets.length;

  // Interpret SFR
  let interpretation: SFRAnalysis['interpretation'];
  let recommendation: string;

  if (sfr > 200) {
    interpretation = 'excellent';
    recommendation = 'Optimal stimulus-to-fatigue ratio. This exercise is highly productive for you.';
  } else if (sfr > 150) {
    interpretation = 'good';
    recommendation = 'Good balance of stimulus and fatigue. Sustainable training volume.';
  } else if (sfr > 100) {
    interpretation = 'moderate';
    recommendation = 'Adequate volume. Monitor fatigue trends - if this stays moderate across sessions, volume may be too high.';
  } else if (sfr > 50) {
    interpretation = 'poor';
    recommendation = 'High fatigue relative to stimulus. Consider reducing sets or improving technique/recovery.';
  } else {
    interpretation = 'excessive';
    recommendation = 'Junk volume detected. You\'re accumulating fatigue without productive stimulus. Cut back significantly.';
  }

  return {
    exerciseId,
    exerciseName,
    totalSets: exerciseSets.length,
    effectiveVolume,
    totalFatigue: fatigueScore,
    sfr,
    interpretation,
    recommendation,
    avgRPE,
    totalVolumeLoad,
    fatiguePerSet,
  };
}

/**
 * Calculate exercise-specific fatigue cost
 * Based on the exercise's own sets, not cumulative workout fatigue
 */
function calculateExerciseFatigueCost(sets: SetLog[]): number {
  let totalFatigue = 0;

  sets.forEach(set => {
    // Skip incomplete sets
    if (!set.completed || !set.actualWeight || !set.actualReps) return;

    // Base fatigue from volume and intensity
    const weightLbs = convertWeight(set.actualWeight, set.weightUnit ?? 'lbs', 'lbs');
    const volumeFatigue = (weightLbs * set.actualReps) / 100; // Normalize volume
    const rpe = set.actualRPE || 7; // Default to RPE 7 if not specified
    const intensityMultiplier = rpe / 10; // RPE 7 = 0.7x, RPE 10 = 1.0x

    // Proximity to failure increases fatigue exponentially
    const proximityFatigue = rpe >= 8 ? Math.pow((rpe - 7), 2) : 1;

    const setFatigue = volumeFatigue * intensityMultiplier * proximityFatigue;
    totalFatigue += setFatigue;
  });

  // Ensure minimum fatigue of 1 to avoid division by zero
  return Math.max(1, totalFatigue);
}

/**
 * Calculate SFR for entire workout
 *
 * @param sets - All sets from workout
 */
export function calculateWorkoutSFR(
  sets: SetLog[]
): WorkoutSFRSummary {
  // Group sets by exercise
  const setsByExercise = new Map<string, SetLog[]>();

  sets.forEach(set => {
    if (!setsByExercise.has(set.exerciseId)) {
      setsByExercise.set(set.exerciseId, []);
    }
    setsByExercise.get(set.exerciseId)!.push(set);
  });

  // Calculate SFR for each exercise with incremental fatigue.
  // Exercise order matters: later exercises are performed under accumulated
  // fatigue from earlier ones, so their fatigue cost should reflect that.
  // Exercise 1 starts with 0 accumulated fatigue, exercise 2 includes
  // fatigue from exercise 1, and so on.
  const exerciseAnalyses: SFRAnalysis[] = [];
  let accumulatedFatigue = 0;

  setsByExercise.forEach((exerciseSets, exerciseId) => {
    const exerciseOwnFatigue = calculateExerciseFatigueCost(exerciseSets);
    const totalFatigueForExercise = exerciseOwnFatigue + accumulatedFatigue;

    // Look up exercise name
    const exercise = defaultExercises.find(ex => ex.id === exerciseId);
    const exerciseName = exercise?.name || exerciseId;

    const analysis = calculateExerciseSFR(
      exerciseSets,
      totalFatigueForExercise,
      exerciseName
    );
    exerciseAnalyses.push(analysis);

    // Add this exercise's fatigue AFTER its SFR is calculated
    accumulatedFatigue += exerciseOwnFatigue;
  });

  // Calculate overall workout SFR
  const totalEffectiveVolume = exerciseAnalyses.reduce((sum, a) => sum + a.effectiveVolume, 0);
  const totalFatigue = exerciseAnalyses.reduce((sum, a) => sum + a.totalFatigue, 0);
  const overallSFR = totalFatigue > 0 ? totalEffectiveVolume / totalFatigue : 0;

  // Overall interpretation
  let overallInterpretation: WorkoutSFRSummary['overallInterpretation'];
  if (overallSFR > 200) overallInterpretation = 'excellent';
  else if (overallSFR > 150) overallInterpretation = 'good';
  else if (overallSFR > 100) overallInterpretation = 'moderate';
  else if (overallSFR > 50) overallInterpretation = 'poor';
  else overallInterpretation = 'excessive';

  // Generate insights
  const insights: string[] = [];

  const excellentExercises = exerciseAnalyses.filter(a => a.interpretation === 'excellent');
  const poorExercises = exerciseAnalyses.filter(a => a.interpretation === 'poor' || a.interpretation === 'excessive');

  if (excellentExercises.length > 0) {
    insights.push(`${excellentExercises.length} exercise(s) with excellent efficiency: ${excellentExercises.map(e => e.exerciseName).join(', ')}`);
  }

  if (poorExercises.length > 0) {
    insights.push(`⚠️ ${poorExercises.length} exercise(s) with poor efficiency: ${poorExercises.map(e => e.exerciseName).join(', ')} - consider reducing volume`);
  }

  const highFatiguePerSet = exerciseAnalyses.filter(a => a.fatiguePerSet > 15);
  if (highFatiguePerSet.length > 0) {
    insights.push(`High fatigue per set detected in: ${highFatiguePerSet.map(e => e.exerciseName).join(', ')} - may indicate form issues or overreaching`);
  }

  return {
    workoutSessionId: '',
    exerciseAnalyses,
    overallSFR,
    overallInterpretation,
    insights,
  };
}

// ============================================================
// DATABASE OPERATIONS
// ============================================================

/**
 * Save SFR analysis to database after workout completion
 */
export async function saveSFRAnalysis(
  userId: string,
  workoutSessionId: string,
  sfrSummary: WorkoutSFRSummary
): Promise<void> {
  if (!userId || sfrSummary.exerciseAnalyses.length === 0) return;

  try {
    // Save individual exercise analyses
    const exerciseRecords = sfrSummary.exerciseAnalyses.map(analysis => ({
      user_id: userId,
      workout_session_id: workoutSessionId,
      exercise_id: analysis.exerciseId,
      exercise_name: analysis.exerciseName,
      total_sets: analysis.totalSets,
      total_volume_load: analysis.totalVolumeLoad,
      effective_volume: analysis.effectiveVolume,
      avg_rpe: analysis.avgRPE,
      total_fatigue: analysis.totalFatigue,
      fatigue_per_set: analysis.fatiguePerSet,
      sfr: analysis.sfr,
      interpretation: analysis.interpretation,
      recommendation: analysis.recommendation,
    }));

    const { error: analysisError } = await supabase
      .from('sfr_analyses')
      .insert(exerciseRecords);

    if (analysisError) {
      console.error('Failed to save SFR analyses:', analysisError);
      return;
    }

    // Save workout summary
    const interpretationCounts = sfrSummary.exerciseAnalyses.reduce(
      (counts, analysis) => {
        counts[analysis.interpretation]++;
        return counts;
      },
      { excellent: 0, good: 0, moderate: 0, poor: 0, excessive: 0 } as Record<string, number>
    );

    const { error: summaryError } = await supabase
      .from('workout_sfr_summaries')
      .insert({
        user_id: userId,
        workout_session_id: workoutSessionId,
        overall_sfr: sfrSummary.overallSFR,
        overall_interpretation: sfrSummary.overallInterpretation,
        total_exercises: sfrSummary.exerciseAnalyses.length,
        excellent_count: interpretationCounts.excellent,
        good_count: interpretationCounts.good,
        moderate_count: interpretationCounts.moderate,
        poor_count: interpretationCounts.poor,
        excessive_count: interpretationCounts.excessive,
        insights: sfrSummary.insights,
      });

    if (summaryError) {
      console.error('Failed to save workout SFR summary:', summaryError);
      return;
    }

    logger.debug(`✅ Saved SFR analysis: ${sfrSummary.exerciseAnalyses.length} exercises, overall SFR: ${sfrSummary.overallSFR.toFixed(0)}`);
  } catch (err) {
    console.error('Error saving SFR analysis:', err);
  }
}
