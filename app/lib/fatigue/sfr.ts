/**
 * Stimulus-to-Fatigue Ratio (SFR) Analysis
 *
 * Research basis:
 * - Israetel et al. (2017): Volume landmarks (MEV, MAV, MRV)
 * - Schoenfeld (2010): Mechanisms of hypertrophy - effective reps concept
 * - Baz-Valle et al. (2021): Proximity to failure and hypertrophy
 *
 * Concept:
 * SFR = Effective Volume / Fatigue Cost
 *
 * High SFR (>200) = Productive training (good stimulus, manageable fatigue)
 * Low SFR (<50) = Junk volume (high fatigue cost, low benefit)
 */

import { logger } from '../logger';
import { SetLog } from '../types';
import { FatigueScore } from '../fatigueModel';
import { supabase } from '../supabase/client';
import { defaultExercises } from '../programs';

// ============================================================
// INTERFACES
// ============================================================

export interface SFRAnalysis {
  exerciseId: string;
  exerciseName: string;
  totalSets: number;
  effectiveVolume: number;       // Volume-weighted by proximity to failure
  totalFatigue: number;           // Cumulative fatigue score
  sfr: number;                    // Stimulus-to-Fatigue Ratio
  interpretation: 'excellent' | 'good' | 'moderate' | 'poor' | 'excessive';
  recommendation: string;

  // Breakdown for insights
  avgRPE: number;
  totalVolumeLoad: number;        // Raw volume (sets × reps × weight)
  fatiguePerSet: number;
}

export interface WorkoutSFRSummary {
  workoutSessionId: string;
  exerciseAnalyses: SFRAnalysis[];
  overallSFR: number;
  overallInterpretation: 'excellent' | 'good' | 'moderate' | 'poor' | 'excessive';
  insights: string[];
}

// ============================================================
// EFFECTIVE VOLUME CALCULATION
// ============================================================

/**
 * Calculate effective volume based on proximity to failure
 *
 * Research: Baz-Valle et al. (2021) - Sets closer to failure drive more growth
 *
 * Weighting:
 * - RPE 9-10 (0-1 RIR): 1.0x multiplier - maximum stimulus
 * - RPE 8 (2 RIR): 0.9x - very effective
 * - RPE 7 (3 RIR): 0.7x - moderately effective
 * - RPE 6 (4 RIR): 0.5x - minimally effective
 * - RPE <6: 0.2x - very low effectiveness (warm-up territory)
 */
function calculateEffectiveVolume(set: SetLog): number {
  const volumeLoad = (set.actualWeight || 0) * (set.actualReps || 0);
  const rpe = set.actualRPE || set.prescribedRPE || 7;

  let effectivenessMultiplier: number;

  if (rpe >= 9) {
    effectivenessMultiplier = 1.0; // Maximum stimulus
  } else if (rpe >= 8) {
    effectivenessMultiplier = 0.9; // Very effective
  } else if (rpe >= 7) {
    effectivenessMultiplier = 0.7; // Moderately effective
  } else if (rpe >= 6) {
    effectivenessMultiplier = 0.5; // Minimally effective
  } else {
    effectivenessMultiplier = 0.2; // Warm-up sets
  }

  return volumeLoad * effectivenessMultiplier;
}

// ============================================================
// SFR CALCULATION
// ============================================================

/**
 * Calculate SFR for a single exercise
 *
 * @param exerciseSets - All sets for this exercise in the workout
 * @param fatigueScore - Fatigue score generated by this exercise
 * @param exerciseName - Name for display purposes
 */
export function calculateExerciseSFR(
  exerciseSets: SetLog[],
  fatigueScore: number,
  exerciseName: string
): SFRAnalysis {
  if (exerciseSets.length === 0) {
    return {
      exerciseId: '',
      exerciseName: '',
      totalSets: 0,
      effectiveVolume: 0,
      totalFatigue: 0,
      sfr: 0,
      interpretation: 'poor',
      recommendation: 'No sets logged',
      avgRPE: 0,
      totalVolumeLoad: 0,
      fatiguePerSet: 0,
    };
  }

  const exerciseId = exerciseSets[0].exerciseId;

  // Calculate total effective volume
  const effectiveVolume = exerciseSets.reduce(
    (sum, set) => sum + calculateEffectiveVolume(set),
    0
  );

  // Calculate raw volume load
  const totalVolumeLoad = exerciseSets.reduce(
    (sum, set) => sum + ((set.actualWeight || 0) * (set.actualReps || 0)),
    0
  );

  // Calculate average RPE
  const rpeValues = exerciseSets.map(s => s.actualRPE || s.prescribedRPE || 7);
  const avgRPE = rpeValues.reduce((a, b) => a + b, 0) / rpeValues.length;

  // Prevent division by zero
  const effectiveFatigue = Math.max(fatigueScore, 1);

  // Calculate SFR
  const sfr = effectiveVolume / effectiveFatigue;

  // Fatigue per set
  const fatiguePerSet = fatigueScore / exerciseSets.length;

  // Interpret SFR
  let interpretation: SFRAnalysis['interpretation'];
  let recommendation: string;

  if (sfr > 200) {
    interpretation = 'excellent';
    recommendation = 'Optimal stimulus-to-fatigue ratio. This exercise is highly productive for you.';
  } else if (sfr > 150) {
    interpretation = 'good';
    recommendation = 'Good balance of stimulus and fatigue. Sustainable training volume.';
  } else if (sfr > 100) {
    interpretation = 'moderate';
    recommendation = 'Adequate volume. Monitor fatigue trends - if this stays moderate across sessions, volume may be too high.';
  } else if (sfr > 50) {
    interpretation = 'poor';
    recommendation = 'High fatigue relative to stimulus. Consider reducing sets or improving technique/recovery.';
  } else {
    interpretation = 'excessive';
    recommendation = 'Junk volume detected. You\'re accumulating fatigue without productive stimulus. Cut back significantly.';
  }

  return {
    exerciseId,
    exerciseName,
    totalSets: exerciseSets.length,
    effectiveVolume,
    totalFatigue: fatigueScore,
    sfr,
    interpretation,
    recommendation,
    avgRPE,
    totalVolumeLoad,
    fatiguePerSet,
  };
}

/**
 * Calculate exercise-specific fatigue cost
 * Based on the exercise's own sets, not cumulative workout fatigue
 */
function calculateExerciseFatigueCost(sets: SetLog[]): number {
  let totalFatigue = 0;

  sets.forEach(set => {
    // Skip incomplete sets
    if (!set.completed || !set.actualWeight || !set.actualReps) return;

    // Base fatigue from volume and intensity
    const volumeFatigue = (set.actualWeight * set.actualReps) / 100; // Normalize volume
    const rpe = set.actualRPE || 7; // Default to RPE 7 if not specified
    const intensityMultiplier = rpe / 10; // RPE 7 = 0.7x, RPE 10 = 1.0x

    // Proximity to failure increases fatigue exponentially
    const proximityFatigue = rpe >= 8 ? Math.pow((rpe - 7), 2) : 1;

    const setFatigue = volumeFatigue * intensityMultiplier * proximityFatigue;
    totalFatigue += setFatigue;
  });

  // Ensure minimum fatigue of 1 to avoid division by zero
  return Math.max(1, totalFatigue);
}

/**
 * Calculate SFR for entire workout
 *
 * @param sets - All sets from workout
 * @param fatigueScores - Fatigue scores by muscle group (UNUSED - replaced with per-exercise calculation)
 */
export function calculateWorkoutSFR(
  sets: SetLog[],
  fatigueScores: FatigueScore[]
): WorkoutSFRSummary {
  // Group sets by exercise
  const setsByExercise = new Map<string, SetLog[]>();

  sets.forEach(set => {
    if (!setsByExercise.has(set.exerciseId)) {
      setsByExercise.set(set.exerciseId, []);
    }
    setsByExercise.get(set.exerciseId)!.push(set);
  });

  // Calculate SFR for each exercise
  const exerciseAnalyses: SFRAnalysis[] = [];

  setsByExercise.forEach((exerciseSets, exerciseId) => {
    // Calculate fatigue based on THIS exercise's sets only
    // This fixes the temporal attribution error where exercises inherited
    // fatigue from exercises that happened after them
    const exerciseFatigue = calculateExerciseFatigueCost(exerciseSets);

    // Look up exercise name
    const exercise = defaultExercises.find(ex => ex.id === exerciseId);
    const exerciseName = exercise?.name || exerciseId;

    const analysis = calculateExerciseSFR(
      exerciseSets,
      exerciseFatigue,
      exerciseName
    );
    exerciseAnalyses.push(analysis);
  });

  // Calculate overall workout SFR
  const totalEffectiveVolume = exerciseAnalyses.reduce((sum, a) => sum + a.effectiveVolume, 0);
  const totalFatigue = exerciseAnalyses.reduce((sum, a) => sum + a.totalFatigue, 0);
  const overallSFR = totalFatigue > 0 ? totalEffectiveVolume / totalFatigue : 0;

  // Overall interpretation
  let overallInterpretation: WorkoutSFRSummary['overallInterpretation'];
  if (overallSFR > 200) overallInterpretation = 'excellent';
  else if (overallSFR > 150) overallInterpretation = 'good';
  else if (overallSFR > 100) overallInterpretation = 'moderate';
  else if (overallSFR > 50) overallInterpretation = 'poor';
  else overallInterpretation = 'excessive';

  // Generate insights
  const insights: string[] = [];

  const excellentExercises = exerciseAnalyses.filter(a => a.interpretation === 'excellent');
  const poorExercises = exerciseAnalyses.filter(a => a.interpretation === 'poor' || a.interpretation === 'excessive');

  if (excellentExercises.length > 0) {
    insights.push(`${excellentExercises.length} exercise(s) with excellent efficiency: ${excellentExercises.map(e => e.exerciseName).join(', ')}`);
  }

  if (poorExercises.length > 0) {
    insights.push(`⚠️ ${poorExercises.length} exercise(s) with poor efficiency: ${poorExercises.map(e => e.exerciseName).join(', ')} - consider reducing volume`);
  }

  const highFatiguePerSet = exerciseAnalyses.filter(a => a.fatiguePerSet > 15);
  if (highFatiguePerSet.length > 0) {
    insights.push(`High fatigue per set detected in: ${highFatiguePerSet.map(e => e.exerciseName).join(', ')} - may indicate form issues or overreaching`);
  }

  return {
    workoutSessionId: '',
    exerciseAnalyses,
    overallSFR,
    overallInterpretation,
    insights,
  };
}

// ============================================================
// BENCHMARKING & TRENDS
// ============================================================

/**
 * Compare current SFR to historical average for this exercise
 * Helps identify if efficiency is improving or declining over time
 */
export function compareSFRToBaseline(
  currentSFR: number,
  historicalAvgSFR: number
): {
  percentChange: number;
  trend: 'improving' | 'stable' | 'declining';
  interpretation: string;
} {
  const percentChange = ((currentSFR - historicalAvgSFR) / historicalAvgSFR) * 100;

  let trend: 'improving' | 'stable' | 'declining';
  let interpretation: string;

  if (percentChange > 10) {
    trend = 'improving';
    interpretation = `Training efficiency up ${percentChange.toFixed(0)}% - you're getting more stimulus with less fatigue`;
  } else if (percentChange < -10) {
    trend = 'declining';
    interpretation = `Training efficiency down ${Math.abs(percentChange).toFixed(0)}% - consider deload or technique review`;
  } else {
    trend = 'stable';
    interpretation = `Training efficiency stable (${percentChange > 0 ? '+' : ''}${percentChange.toFixed(0)}%)`;
  }

  return {
    percentChange,
    trend,
    interpretation,
  };
}

// ============================================================
// DATABASE OPERATIONS
// ============================================================

/**
 * Save SFR analysis to database after workout completion
 */
export async function saveSFRAnalysis(
  userId: string,
  workoutSessionId: string,
  sfrSummary: WorkoutSFRSummary
): Promise<void> {
  if (!userId || sfrSummary.exerciseAnalyses.length === 0) return;

  try {
    // Save individual exercise analyses
    const exerciseRecords = sfrSummary.exerciseAnalyses.map(analysis => ({
      user_id: userId,
      workout_session_id: workoutSessionId,
      exercise_id: analysis.exerciseId,
      exercise_name: analysis.exerciseName,
      total_sets: analysis.totalSets,
      total_volume_load: analysis.totalVolumeLoad,
      effective_volume: analysis.effectiveVolume,
      avg_rpe: analysis.avgRPE,
      total_fatigue: analysis.totalFatigue,
      fatigue_per_set: analysis.fatiguePerSet,
      sfr: analysis.sfr,
      interpretation: analysis.interpretation,
      recommendation: analysis.recommendation,
    }));

    const { error: analysisError } = await (supabase
      .from('sfr_analyses') as any)
      .insert(exerciseRecords);

    if (analysisError) {
      console.error('Failed to save SFR analyses:', analysisError);
      return;
    }

    // Save workout summary
    const interpretationCounts = sfrSummary.exerciseAnalyses.reduce(
      (counts, analysis) => {
        counts[analysis.interpretation]++;
        return counts;
      },
      { excellent: 0, good: 0, moderate: 0, poor: 0, excessive: 0 } as Record<string, number>
    );

    const { error: summaryError } = await (supabase
      .from('workout_sfr_summaries') as any)
      .insert({
        user_id: userId,
        workout_session_id: workoutSessionId,
        overall_sfr: sfrSummary.overallSFR,
        overall_interpretation: sfrSummary.overallInterpretation,
        total_exercises: sfrSummary.exerciseAnalyses.length,
        excellent_count: interpretationCounts.excellent,
        good_count: interpretationCounts.good,
        moderate_count: interpretationCounts.moderate,
        poor_count: interpretationCounts.poor,
        excessive_count: interpretationCounts.excessive,
        insights: sfrSummary.insights,
      });

    if (summaryError) {
      console.error('Failed to save workout SFR summary:', summaryError);
      return;
    }

    logger.debug(`✅ Saved SFR analysis: ${sfrSummary.exerciseAnalyses.length} exercises, overall SFR: ${sfrSummary.overallSFR.toFixed(0)}`);
  } catch (err) {
    console.error('Error saving SFR analysis:', err);
  }
}

/**
 * Get SFR history for a specific exercise
 */
export async function getExerciseSFRHistory(
  userId: string,
  exerciseId: string,
  limit: number = 10
): Promise<SFRAnalysis[]> {
  const { data, error } = await supabase
    .from('sfr_analyses')
    .select('*')
    .eq('user_id', userId)
    .eq('exercise_id', exerciseId)
    .order('recorded_at', { ascending: false })
    .limit(limit);

  if (error || !data) {
    console.error('Failed to fetch exercise SFR history:', error);
    return [];
  }

  return (data as any[]).map((record: any) => ({
    exerciseId: record.exercise_id,
    exerciseName: record.exercise_name,
    totalSets: record.total_sets,
    effectiveVolume: record.effective_volume,
    totalFatigue: record.total_fatigue,
    sfr: record.sfr,
    interpretation: record.interpretation,
    recommendation: record.recommendation,
    avgRPE: record.avg_rpe,
    totalVolumeLoad: record.total_volume_load,
    fatiguePerSet: record.fatigue_per_set,
  }));
}

/**
 * Get recent workout SFR summaries
 */
export async function getWorkoutSFRHistory(
  userId: string,
  limit: number = 10
): Promise<any[]> {
  const { data, error } = await supabase
    .from('workout_sfr_summaries')
    .select('*')
    .eq('user_id', userId)
    .order('recorded_at', { ascending: false })
    .limit(limit);

  if (error || !data) {
    console.error('Failed to fetch workout SFR history:', error);
    return [];
  }

  return data || [];
}

/**
 * Get average SFR for an exercise (for trend analysis)
 */
export async function getExerciseAvgSFR(
  userId: string,
  exerciseId: string,
  daysBack: number = 90
): Promise<number> {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - daysBack);

  const { data, error } = await supabase
    .from('sfr_analyses')
    .select('sfr')
    .eq('user_id', userId)
    .eq('exercise_id', exerciseId)
    .gte('recorded_at', cutoffDate.toISOString());

  if (error || !data || data.length === 0) {
    return 0;
  }

  const avgSFR = (data as any[]).reduce((sum, record) => sum + record.sfr, 0) / data.length;
  return avgSFR;
}

/**
 * Identify exercises with poor efficiency (junk volume)
 */
export async function identifyJunkVolumeExercises(
  userId: string,
  minSessions: number = 3
): Promise<Array<{
  exerciseId: string;
  exerciseName: string;
  avgSFR: number;
  sessionCount: number;
  recommendation: string;
}>> {
  const { data, error } = await (supabase.rpc as any)('identify_junk_volume_exercises', {
    p_user_id: userId,
    p_min_sessions: minSessions,
  });

  if (error) {
    console.error('Failed to identify junk volume exercises:', error);
    return [];
  }

  return data || [];
}

/**
 * Get exercise efficiency leaderboard (best performing exercises)
 */
export async function getExerciseEfficiencyLeaderboard(
  userId: string,
  limit: number = 20
): Promise<Array<{
  exerciseId: string;
  exerciseName: string;
  avgSFR: number;
  timesPerformed: number;
  bestSFR: number;
  worstSFR: number;
}>> {
  const { data, error } = await supabase
    .from('exercise_efficiency_leaderboard')
    .select('*')
    .eq('user_id', userId)
    .order('avg_sfr', { ascending: false })
    .limit(limit);

  if (error || !data) {
    console.error('Failed to fetch efficiency leaderboard:', error);
    return [];
  }

  return (data as any[]).map((record: any) => ({
    exerciseId: record.exercise_id,
    exerciseName: record.exercise_name,
    avgSFR: record.avg_sfr,
    timesPerformed: record.times_performed,
    bestSFR: record.best_sfr,
    worstSFR: record.worst_sfr,
  }));
}
